# Implement Error Handling in T-SQL
An error indicates a problem or notable issue that arises during a database operation. 
Errors can be generated by the SQL Server Database Engine in response to an event or failure at the system level; or you can generate application errors in your Transact-SQL code.

Every error is composed of;
- Error Number: A unique number that identifies the error.
- Message: A description of the error.
- Severity: Numeric indication of seriousness from 1 to 25.
- State: Internal state code for the database engine to indicate the location of the error.
- Procedure: The name of the stored procedure or trigger where the error occurred.
- Line Number: The line number in the batch or stored procedure where the error occurred.


## System Errors
System errors are generated by the SQL Server Database Engine and are returned to the client application.

## Custom Errors
Custom errors are generated by the user and can be raised using the `RAISERROR` statement.

We can define them with 2 ways;
- sp_addmessage
  - Add a new message to the `sys.messages` catalog view.
  - The user for the message must be a member of the sysadmin or serveradmin fixed server roles.
- Create inline error.

> The error numbers used for custom errors must be 50001 or above.

```tsql
/* 
  Syntax:
    
  sp_addmessage [ @msgnum= ] msg_id , [ @severity= ] severity , [ @msgtext= ] 'msg' 
     [ , [ @lang= ] 'language' ] 
     [ , [ @with_log= ] { 'TRUE' | 'FALSE' } ] --  When set to TRUE, the error will also be recorded in the Windows Application log.
     [ , [ @replace= ] 'replace' ] -- If we set this value, the message will be replaced with the new message.
*/


-- Create a new message
EXEC sp_addmessage 
@msgnum = 50001, 
@severity = 16,
 @msgtext = N'This is a custom error message.';
```


## RAISERROR
The `RAISERROR` statement generates an error message and initiates error processing for the session.

Both PRINT and RAISERROR can be used to return information or warning messages to applications. 
RAISERROR allows applications to raise an error that could then be caught by the calling process.

> Using a PRINT statement is similar to raising an error of severity 10.

```tsql
RAISERROR (
    N'%s %d %s %s.', -- Message text
    10, -- Severity
    1, -- State
    N'its a custom error', -- First argument
    5, -- Second argument
    N'and its a custom error 2', -- Third argument
    N'and its a custom error 3' -- Fourth argument
);

-- Output
-- Msg 50000, Level 10, State 1, Line 1
-- its a custom error 5 and its a custom error 2 and its a custom error 3.
```

> They always have error number 50000.


## THROW
The `THROW` statement raises an exception and transfers execution to a CATCH block of a TRYâ€¦CATCH construct in SQL Server.

Throws have fixed severity level 16.
The messages returned by THROW aren't related to any entries in sys.sysmessages.
Errors raised by THROW only cause transaction abort when used in conjunction with `SET XACT_ABORT ON` and the session is terminated.

```tsql
THROW 50001, 'This is a custom error message.', 1; -- 1 is state
```


## Capture Error Codes with @@ERROR
`@@ERROR` returns the error number for the last Transact-SQL statement executed.
This value is 0 if the statement was successful. This means, we can call `@@ERROR` just 1 time after error occurred.

> Microsoft Doc:
> Structured exception handling was introduced in SQL Server 2005 and provides a strong alternative to using @@ERROR.
> A large amount of existing SQL Server error handling code is based on @@ERROR, so it is important to understand how to work with it.

```tsql
RAISERROR ('An error occurred.', 16, 1);
IF @@ERROR <> 0
  PRINT 'Error=' + CAST(@@ERROR AS VARCHAR(8));
GO;

-- Output
-- Msg 50000, Level 16, State 1, Line 1
-- An error occurred.
-- Error=0

-- We got 0 because we called 1 time after error occurred. After called it second time. It completely reset.

RAISERROR ('An error occurred.', 16, 1);
DECLARE @error INT;
SET @error = @@ERROR;
IF @error <> 0
  PRINT 'Error=' + CAST(@error AS VARCHAR(8));
GO;

-- Output
-- Msg 50000, Level 16, State 1, Line 1
-- An error occurred.
-- Error=50000
```


# TRY...CATCH
`TRY...CATCH` is a structured exception handling mechanism provided by SQL Server.
It allows you to handle errors gracefully without stopping the execution of a batch of statements.
There is not "finally block" in SQL Server.

```tsql
BEGIN TRY
  -- Generate a divide-by-zero error.
  SELECT 1 / 0;
END TRY
BEGIN CATCH
  PRINT 'An error occurred.';
END CATCH;

-- Output
-- Msg 8134, Level 16, State 1, Line 3
-- Divide by zero error encountered.
-- An error occurred.
```

Also, we can reach the error details with functions;
- `ERROR_NUMBER()`: Returns the error number.
- `ERROR_MESSAGE()`: Returns the error message.
- `ERROR_SEVERITY()`: Returns the severity.
- `ERROR_STATE()`: Returns the state.
- `ERROR_PROCEDURE()`: Returns the name of the stored procedure or trigger where the error occurred.
- `ERROR_LINE()`: Returns the line number in the batch or stored procedure where the error occurred.

```tsql
BEGIN TRY
  -- Generate a divide-by-zero error.
  SELECT 1 / 0;
END TRY
BEGIN CATCH
  PRINT 'Error Number: ' + CAST(ERROR_NUMBER() AS VARCHAR(8));
  PRINT 'Error Message: ' + ERROR_MESSAGE();
  PRINT 'Error Severity: ' + CAST(ERROR_SEVERITY() AS VARCHAR(8));
  PRINT 'Error State: ' + CAST(ERROR_STATE() AS VARCHAR(8));
  PRINT 'Error Procedure: ' + ISNULL(ERROR_PROCEDURE(), '');
  PRINT 'Error Line: ' + CAST(ERROR_LINE() AS VARCHAR(8));
END CATCH;

-- Output
-- Msg 8134, Level 16, State 1, Line 3
-- Divide by zero error encountered.
-- Error Number: 8134
-- Error Message: Divide by zero error encountered.
-- Error Severity: 16
-- Error State: 1
-- Error Procedure:
-- Error Line: 3
```
 
  
---

Noncatchable Errors:
- Compile errors, such as syntax errors, that prevent a batch from running.
- you could create a stored procedure that refers to an unknown table. An error is only thrown when the procedure tries to resolve the name of the table to an objectid.

---

## RETHROW
`RETHROW` is used to raise the original exception that was captured in the `CATCH` block.

```tsql
BEGIN TRY
  -- Generate a divide-by-zero error.
  SELECT 1 / 0;
END TRY
BEGIN CATCH
  PRINT 'An error occurred.';
  THROW;
END CATCH;

-- Output
-- Msg 8134, Level 16, State 1, Line 3
-- Divide by zero error encountered.
-- An error occurred.
-- Msg 8134, Level 16, State 1, Line 7
-- Divide by zero error encountered.
```